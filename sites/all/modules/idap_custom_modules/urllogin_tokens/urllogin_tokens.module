<?php
include_once(drupal_get_path('module','urllogin').'/urllogin_security.inc');

/* Implements hook_token_info() */

function urllogin_tokens_token_info() {
	$types['urllogin_tokens'] = array(
		'name' => t('URLLogin Tokens'),
		'description' => t('Create tokens to include in subscriptions emails to enable users to login by clicking tokenised link'),
	);
	
	$urllogin_tokens['urllogin_user_token'] = array(
		'name' => t('URLLogin Token'),
		'description' => t('Token string generated by urllogin module'),
		'type' => 'current-user',
	);
	$urllogin_tokens['urllogin_user_name'] = array(
		'name' => t('URLLogin Token'),
		'description' => t('Username generated by urllogin module'),
	);
	
	return array(
		'types' => $types,
		'tokens' => array('urllogin_tokens' => $urllogin_tokens),
	);
}

function urllogin_tokens_tokens($type, $tokens, array $data = array(), array $options = array()) {
	$account = user_load($GLOBALS['user']->uid);
	
	if ($type == 'urllogin_tokens' && !empty($data['user'])) {
		foreach($tokens as $name=>$original) {
			switch($name) {
				case 'urllogin_user_token':
					$replacements[$original] = _get_urllogin_token($account);
					break;
				case 'urllogin_user_name':
					$replacements[$original] = _get_urllogin_username($account);
					break;
			}
		}
	}
	return $replacements;
}

function _get_urllogin_token($account) {
	$uid = $account->uid;
	$codekey = variable_get('urllogin_codekey', 0);
	$urlstr = urllogin_encode($uid, $codekey, urllogin_passphrase());
	return $urlstr;
}

function _get_urllogin_username($account) {
	return $account->name;
}
	
	
	
	/*
	$uid = (int)$testuid; //this will sanitize it as well
	  if (isset($GLOBALS['urllogin_passphrase'])) { // first see if it is in settings.php
	    $passkey = 'set from settings.php';
	  }
	  else {
	    $passkey = variable_get('urllogin_passphrase', 'no passphrase defined');
	    if (variable_get('urllogin_add_dbpass', '0') != 0) {
	      // we don't really want to give away the actual database access string
	      $passkey .= ' + database string';
	    }
	  }
	  $codekey = variable_get('urllogin_codekey', 0);
	  $codemin = variable_get('urllogin_codemin', 0);
	  $page = '<h2> ' . urllogin_help('admin/help#checkin', 0) . '</h2><ul>';
	  $page .= '<li>' . t('Test UID') . ': ' . $uid . '</li>';
	  $page .= '<li>' . t('Passphrase') . ': ' . $passkey . '</li>';
	  $page .= '<li>' . t('Current Validation number') . ': ' . $codekey . '</li>';
	  $page .= '<li>' . t('Minimum validation number') . ': ' . $codemin . '</li>';
	  $urlstr = urllogin_encode($uid, $codekey, urllogin_passphrase());
	  $page .= '<li>' . t('Encoded URL access string: [') . $urlstr . ']</li>';
	  $page .= '</ul>';
	  $testlink = 'l_test/' . $urlstr;
	  $page .= '<p>' . t('This page can be used to generate individual access strings for testing purposes.
	    Simply add the UID of the user to the end of the url for this page, revisit the page and the
	    access string will be displayed above.') . '</p><p>'
	   . t('To test the access string, use') . ' ' . l(t('the test page'), 'l_test/') . ' '
	   . t('by appending the access string to it, e.g.:') . ' '
	   . l($testlink, $testlink) . '</p>';
	  return $page; */

/* function user_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $url_options = array('absolute' => TRUE);
  if (isset($options['language'])) {
    $url_options['language'] = $options['language'];
    $language_code = $options['language']->language;
  }
  else {
    $language_code = NULL;
  }
  $sanitize = !empty($options['sanitize']);

  $replacements = array();

  if ($type == 'user' && !empty($data['user'])) {
    $account = $data['user'];
    foreach ($tokens as $name => $original) {
      switch ($name) {
        // Basic user account information.
        case 'uid':
          // In the case of hook user_presave uid is not set yet.
          $replacements[$original] = !empty($account->uid) ? $account->uid : t('not yet assigned');
          break;

        case 'name':
          $name = format_username($account);
          $replacements[$original] = $sanitize ? check_plain($name) : $name;
          break;

        case 'mail':
          $replacements[$original] = $sanitize ? check_plain($account->mail) : $account->mail;
          break;

        case 'url':
          $replacements[$original] = !empty($account->uid) ? url("user/$account->uid", $url_options) : t('not yet assigned');
          break;

        case 'edit-url':
          $replacements[$original] = !empty($account->uid) ? url("user/$account->uid/edit", $url_options) : t('not yet assigned');
          break;

        // These tokens are default variations on the chained tokens handled below.
        case 'last-login':
          $replacements[$original] = !empty($account->login) ? format_date($account->login, 'medium', '', NULL, $language_code) : t('never');
          break;

        case 'created':
          // In the case of user_presave the created date may not yet be set.
          $replacements[$original] = !empty($account->created) ? format_date($account->created, 'medium', '', NULL, $language_code) : t('not yet created');
          break;
      }
    }

    if ($login_tokens = token_find_with_prefix($tokens, 'last-login')) {
      $replacements += token_generate('date', $login_tokens, array('date' => $account->login), $options);
    }

    if ($registered_tokens = token_find_with_prefix($tokens, 'created')) {
      $replacements += token_generate('date', $registered_tokens, array('date' => $account->created), $options);
    }
  }

  if ($type == 'current-user') {
    $account = user_load($GLOBALS['user']->uid);
    $replacements += token_generate('user', $tokens, array('user' => $account), $options);
  }

  return $replacements;
} */